#  This "input" configures a global authorization rule to enable public access to
#  all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
input AMPLIFY {
  globalAuthRule: AuthRule = { allow: public }
} #  FOR TESTING ONLY!
# user collection

type User @model {
  id: ID!
  firstName: String!
  lastName: String!
  bio: String
  permissions: [Permission!]!
  schemeVersion: Int!
}

type Permission {
  permissionType: PermissionType!
  allowedEntities: [ID!]! # connect possibly via entity
}

enum PermissionType {
  READ
  CHANGEMASTERDATA
  CREATEINTERVENTIONS
  EXECUTESURVEYS
  CREATESUBENTITIES
  ADMIN
}

# config collection

type Config @model {
  id: ID!
  schemeVersion: Int!
  name: String!
  colorTheme: ColorTheme
  storagePaths: StoragePaths!
}

type ColorTheme {
  highlight: String # chosen by user # todo: default
  secundaryHighlight: String # chosen by user # todo: default
  backgroundOneLight: String # auto generate via api
  backgroundTwoLight: String # auto generate via api
  backgroundOneDark: String # auto generate via api
  backgroundTwoDark: String # auto generate via api
}

type StoragePaths {
  ownerPic: String
  ownerIcon: String
  # todo: check whether this approach makes sense
}

# level collection

type Level @model {
  id: ID!
  name: String!
  description: String!
  parentLevelID: ID
  parentLevel: Level @belongsTo
  childLevel: Level @hasOne
  interventionsAllowed: Boolean!
  allowedInterventionIDs: [ID!]
  allowedInterventions: [Intervention!] @hasMany
  customDatas: [CustomData!]!
  schemeVersion: Int!
}

type CustomData {
  id: ID! # todo: check how to generate it
  name: String!
  type: Type!
}

enum Type {
  INT
  STRING
}

# intervention collection

type Intervention @model {
  id: ID!
  schemeVersion: Int!
  name: String!
  description: String!
  interventionType: InterventionType!
  contents: [Content!]! @hasMany
  surveys: [Survey!]! @hasMany
}

enum InterventionType {
  TECHNOLOGY
  EDUCATION
}

# content collection

type Content @model {
  id: ID! # todo: dependent ID
  schemeVersion: Int!
  intervention: Intervention @belongsTo
  name: String!
  tags: [String!]!
}

# survey collection
type Survey @model {
  id: ID! # todo: dependent ID
  schemeVersion: Int!
  intervention: Intervention @belongsTo
  name: String!
  description: String!
  questions: [Question!]!
}

enum SurveyType {
  INITIAL
  DEFAULT
}

enum QuestionType {
  TEXT
  SINGLECHOICE
  MULTIPLECHOICE
  PICTURE
  PICTUREWITHTAGS
  AUDIO
}

type Question {
  id: ID! # todo: dependent ID
  text: String!
  type: QuestionType!
  questionOptions: [QuestionOption!]
}

type QuestionOption {
  id: ID!
  text: String!
  followupQuestion: Question
}

# entityCollection

# todo: check whether binding the children makes sense
type Entity @model {
  id: ID!
  schemeVersion: Int!
  parentEntity: Entity @belongsTo
  childEntities: [Entity!] @hasMany
  level: Level! @hasOne
  location: Location
  name: String!
  customDatas: [AppliedCustomData]!
  appliedInterventions: [AppliedIntervention!]! @hasMany
}

type Location {
  latitude: Float
  longitude: Float
}

type AppliedCustomData {
  customDataID: ID! # todo: we might possibly annotate the connection
  type: Type!
  name: String!
  intValue: Int
  stringValue: String
}

# appliedInterventionCollection

# todo: possibly add bidirectional reference entity
type AppliedIntervention @model {
  id: ID!
  schemeVersion: Int!
  userID: ID!
  interventionID: ID!
  location: Location
  executedSurveys: [ExecutedSurvey!]! @hasMany
}

# executedSurveyCollection

type ExecutedSurvey @model {
  id: ID!
  schemeVersion: Int!
  appliedIntervention: AppliedIntervention! @belongsTo
  survey: Survey! @hasOne
  userID: ID!
  date: AWSDateTime!
  location: Location
  answers: [QuestionAnswer!]!
}

type QuestionAnswer {
  id: ID! # todo: dependent ID
  questionID: ID! # todo: dependent ID
  date: AWSDateTime!
  type: QuestionType!
  text: String
  questionOptions: [QuestionOption!]
  markings: [Marking!]
  # todo: possibly also pic/audio path
}

type Marking {
  height: Float!
  width: Float!
  description: String
}

type Task @model {
  id: ID!
  title: String!
  text: String
  dueDate: AWSDateTime
  finishedDate: AWSDateTime
  location: Location
  userID: ID!
  entityID: ID
  appliedInterventionID: ID
  executedSurveyID: ID
  # todo: what to do with audio
}